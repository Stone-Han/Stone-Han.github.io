<!doctype html>



  


<html class="theme-next pisces use-motion">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="C++,">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2">






<meta name="description" content="C++ Standard Library(C++标准库) Standard Template Library（STL，标准模板库）C++标准库&amp;gt;STL，除了对六大类型的封装之外，C++标准库还封装了其他一些东西。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++标准库">
<meta property="og:url" content="http://yoursite.com/2018/05/01/C++标准库/index.html">
<meta property="og:site_name" content="StoneHan&#39;s blog">
<meta property="og:description" content="C++ Standard Library(C++标准库) Standard Template Library（STL，标准模板库）C++标准库&amp;gt;STL，除了对六大类型的封装之外，C++标准库还封装了其他一些东西。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.imgur.com/u5C5oY9.png">
<meta property="og:image" content="https://i.imgur.com/jA33Pxf.png">
<meta property="og:image" content="https://i.imgur.com/psYUDyM.png">
<meta property="og:image" content="https://i.imgur.com/fxCLjet.png">
<meta property="og:image" content="https://i.imgur.com/R9BqVxp.png">
<meta property="og:image" content="https://i.imgur.com/c4bRoDz.png">
<meta property="og:image" content="https://i.imgur.com/YTPUHq3.png">
<meta property="og:image" content="https://i.imgur.com/t42LhlC.png">
<meta property="og:image" content="https://i.imgur.com/MKOTuKc.png">
<meta property="og:image" content="https://i.imgur.com/BTcnGQg.png">
<meta property="og:image" content="https://i.imgur.com/N21gcjY.png">
<meta property="og:image" content="https://i.imgur.com/symkawk.png">
<meta property="og:image" content="https://i.imgur.com/kLhkcRn.png">
<meta property="og:image" content="https://i.imgur.com/yomZTeh.png">
<meta property="og:image" content="https://i.imgur.com/UvMF98x.png">
<meta property="og:image" content="https://i.imgur.com/BLlPEyg.png">
<meta property="og:image" content="https://i.imgur.com/Jk6QPjd.png">
<meta property="og:image" content="https://i.imgur.com/QIsE17Z.png">
<meta property="og:image" content="https://i.imgur.com/XC1Nq16.png">
<meta property="og:image" content="https://i.imgur.com/DpBxGBS.png">
<meta property="og:image" content="https://i.imgur.com/uIwhVDf.png">
<meta property="og:image" content="https://i.imgur.com/Cw96Ahr.png">
<meta property="og:image" content="https://i.imgur.com/mlcMk9j.png">
<meta property="og:updated_time" content="2018-08-28T13:05:30.938Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++标准库">
<meta name="twitter:description" content="C++ Standard Library(C++标准库) Standard Template Library（STL，标准模板库）C++标准库&amp;gt;STL，除了对六大类型的封装之外，C++标准库还封装了其他一些东西。">
<meta name="twitter:image" content="https://i.imgur.com/u5C5oY9.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2018/05/01/C++标准库/">


  <title> C++标准库 | StoneHan's blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">StoneHan's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">韩苏东的个人博客</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++标准库
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-01T18:25:09+08:00" content="2018-05-01">
              2018-05-01
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li>C++ Standard Library(C++标准库)</li>
<li>Standard Template Library（STL，标准模板库）<br>C++标准库&gt;STL，除了对六大类型的封装之外，C++标准库还封装了其他一些东西。</li>
</ul>
<a id="more"></a>

<h1 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h1><ul>
<li>容器 Containers</li>
<li>分配器 Allocators</li>
<li>算法 Algorithms</li>
<li>迭代器 Iterators</li>
<li>适配器 Adapters</li>
<li>仿函数 Functors</li>
</ul>
<p>程序=算法+数据结构。数据结构也就是这里的容器，因为容易不需要管内存分配的事情，所以分配器负责这部分。另一部分实现了算法。但是算法不是在容器的类里面的，所以要对容器进行操作需要使用迭代器。另外对类进行加减的行为称为仿函数。适配器可以对容器、迭代器、仿函数进行转换。</p>
<p>问题：<br><strong>一个程序里面可以用两个using namespace吗？</strong></p>
<h1 id="GP-vs-OOP"><a href="#GP-vs-OOP" class="headerlink" title="GP vs. OOP"></a>GP vs. OOP</h1><p>C++标准库的主要思想并不是OOP（继承关系不是很复杂），而是GP。 OOP是将data和method联系在一起，而GP却是将data和method分开来。它用全局的函数，通过迭代器进行沟通。这样的好处是，containers和algorithm可以分别开发。list容器中有sort函数，而vector和deque没有sort函数，需要使用全局的排序函数。全局的排序函数有对指针直接进行加减乘除的操作，而list是链表，不能这样对指针进行加减乘除。</p>
<p><strong>操作符重载</strong> &amp; <strong>模板</strong>是标准库的基础。</p>
<p>模板分为：类模板，函数模板，成员模板。</p>
<p>模板还分为泛化，全特化和偏特化。</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>分类：</p>
<ul>
<li>Sequence Containers</li>
<li>Assosiative Containers(主要用于查找，主要用红黑树实现set/map)</li>
<li>Unordered Container(实际还是一种Assoiative Containers, C++11, 用hashtable实现，开链法)</li>
</ul>
<p><img src="https://i.imgur.com/u5C5oY9.png" alt></p>
<p>这个图展示了各种容器之间的基层与衍生层的关系，这里的衍生并非继承，而是复合。</p>
<p>蓝色的框里展示的是一个对象的大小，不包含数据。</p>
<h2 id="Sequence-Containers"><a href="#Sequence-Containers" class="headerlink" title="Sequence Containers"></a>Sequence Containers</h2><p><img src="https://i.imgur.com/jA33Pxf.png" alt></p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array的实现比vector更简单，它的具体实现如下图：</p>
<p><img src="https://i.imgur.com/psYUDyM.png" alt></p>
<p>array的data就是 <em>M</em>instance[_Nm ? _Nm : 1],类型是value_type，就是传入的第一个模板参数。</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector是前开后闭的。</p>
<p>vector只有一个push_back()，因为如果从前面插入的话，后面所有的元素都要挪动位置。</p>
<p>增长的速度是2倍2倍地增长。先从另外一个地方找一个两倍大的空间，然后把原来的都搬过来，所以成长的速度比较慢。可以使用size()和capacity()来看当前的实际大小和分配的空间大小。</p>
<p>vector 的具体实现有三个指针：start, finish, end_of_storage<br>下面这个图展示了vector的成员变量和一些函数。</p>
<p><img src="https://i.imgur.com/fxCLjet.png" alt></p>
<p>因为vector是连续存储，所以vector的迭代器实际上是指针。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><img src="https://i.imgur.com/R9BqVxp.png" alt></p>
<p>首先看List类，包括一个link_type的node，link_type是个<code>list_node*</code>，也就是个指针，所以list包括了一个指针，所以大小为4(G2.9). 然后看list_node包括两个指针，prev和next和数据data，这两个指针指向<code>void*</code>，这意味着这两个指针在使用的时候需要类型转换。后面的版本会改进。</p>
<p>所有的线性容器，除了array之外都是前闭后开的，后开的意思就是最后一个元素不是数据元素。为了实现这个，会加一个空白结点（图中灰色结点）。</p>
<h4 id="list-的-iterator"><a href="#list-的-iterator" class="headerlink" title="list 的 iterator"></a>list 的 iterator</h4><p>为了实现iterator像指针一样，必须要对操作符进行重载。主要是对++,–,*,-&gt;的重载。这里拿++举例。</p>
<p><img src="https://i.imgur.com/c4bRoDz.png" alt></p>
<p>因为++i和i++都是单目运算操作符，因此编译器并没有办法区分，因此设计了两个不同的函数，一个是前++<code>operator++()</code>，一个是后++<code>operator++(int)</code>。</p>
<p>先来看图下面的前++，这个函数取当前节点的next指针，然后返回这个指针。</p>
<p>而后++，<code>self tmp = *this</code>这句并不会唤起<code>operator*</code>这个函数，而是会唤起拷贝构造函数，*this被解释为拷贝构造函数的参数。如图中深蓝箭头1所指的函数。 然后再进行++，返回tmp。</p>
<p>另外注意这两个函数的返回值。参考int的++操作，由于C++不允许对整数进行两次后++，即i++++是错误的，所以后++返回的不是一个引用，而前++返回引用，可以多次连续++。</p>
<p>另外，对于*和-&gt;的重载如下：</p>
<pre><code>T&amp; operator*() const
{return (*node).data;}

T* operator-&gt;() const
{return &amp;(operator*());}</code></pre><p>对于<code>*</code>，就是解引用，<code>*it</code>就是指一个object，所以返回的是data, 而对于-&gt;实际上是指针调用，所以返回的是data的指针。</p>
<h4 id="G4-9"><a href="#G4-9" class="headerlink" title="G4.9"></a>G4.9</h4><p>改进：</p>
<ul>
<li>模板参数只有一个</li>
<li>node在结构有parent</li>
<li>node的成员type比较精确（指针指向自己）</li>
</ul>
<p>但是G4.9的继承关系比较复杂。</p>
<p>G4.9版本的结构基本上是一个容器继承一个基类，这个容器有一个指针指向impl实现，这个实现public继承allocator。变得复杂是为了一个OO的目标，一个class里面有一个指针表现实现手法，这种模型叫做handle-body。但是侯捷认为不应该是public继承，因为这表示“是一个”，但是impl并不是allocator。</p>
<p>在2.9版是一个指针指向空白结点，到4.9是这个结构直接包括了两个指针，所以size变成了8.</p>
<p><strong>max_size()是如何计算的？</strong></p>
<p><strong>list自身也有sort函数，全局也有sort函数，用容器自身的排序函数会比较快。</strong></p>
<h4 id="forward-list"><a href="#forward-list" class="headerlink" title="forward list"></a>forward list</h4><p>只提供push_front()<strong>为什么？这个不也是个list吗？不是动态增长的吗？</strong></p>
<p>slist:(不属于标准库，但是用法和forward list相同)</p>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p><img src="https://i.imgur.com/YTPUHq3.png" alt></p>
<p>deque可以向前或者向后扩充。</p>
<p>deque每次扩充都扩充一个buffer，如图所示，向后扩充如果不够，就分配一个buffer，同理向前扩充也一样。deque中间控制的地方是个vector，这个vector聪明的地方在于，如果现在buffer满了，那么在扩充之后它会保持原来的元素在buffer中间，这样便于向两边扩展。</p>
<p>deque的iterator包括四个指针，当指针指向buffer的最后一个元素，再加加时，指针应该指向下一个buffer的第一个元素，所以有一个node指针，指向中控中心。另外还有两个iterator，也就是start和finish，分别是这个容器的头和尾。</p>
<p><img src="https://i.imgur.com/t42LhlC.png" alt></p>
<p>deque的成员有一个指针map_pointer，一个size，两个迭代器start,finish，其中每个包括四个指针，所以deque的大小为4<em>4</em>2+4+4=40.</p>
<p>deque的模板默认参数有一个缓冲区大小默认为0，有一个计算缓冲区大小的函数__deque_buf_size，如果不为0，则设定为n，如果为0，设定为默认大小。</p>
<p>deque的insert函数需要判断插入的元素距离头比较近还是距离尾比较近，因为它需要移动其他元素并且可以双向移动。</p>
<p>deque如何模拟连续空间？都是deque iterator的功劳。<br>这是一些基本操作：</p>
<p><img src="https://i.imgur.com/MKOTuKc.png" alt></p>
<p>其中<code>-</code>的重载：</p>
<p><img src="https://i.imgur.com/BTcnGQg.png" alt></p>
<p>首先计算这里面有几个buffer，乘以buffer_size，然后再加上头和尾的元素。</p>
<ul>
<li>对++和–的重载：</li>
</ul>
<p><img src="https://i.imgur.com/N21gcjY.png" alt></p>
<p>对++的重载有两个，一个是前++，一个是后++。首先检查加了之后有没有到达缓冲区尾端，如果到达就跳到下一个节点的起点。其中<code>set_node</code>函数就是跳到下一个缓冲区，包括重新设置first和last指针。</p>
<p>对–的重载也有两个。–首先检查当前是不是在缓冲区的起点，如果是的话就跳到前一个缓冲区的末端。</p>
<p><img src="https://i.imgur.com/symkawk.png" alt></p>
<p>另外deque还有+=和+的操作。其中+就是调用+=。<br>+=的逻辑是这样的：首先计算出来要跳到的位置offset，如果offset在当前buffer的区域，直接跳。否则计算需要跳几个缓冲区，切换到正确的缓冲区再跳到元素的位置。</p>
<p>而-=直接调用+=(-n)就可以。</p>
<h3 id="stack-queue"><a href="#stack-queue" class="headerlink" title="stack/queue"></a>stack/queue</h3><p><img src="https://i.imgur.com/kLhkcRn.png" alt></p>
<p>stack:push_back,pop_back</p>
<p>queue:push_back,pop_front</p>
<p>实际上deque已经包含了stack和queue，所以也叫做adapter.</p>
<p><strong>stack和queue都不允许遍历，也不提供iterator</strong><br>因为stack和queue是先进先出/先进后出，所以不提供iterator，这样就会破坏stack/queue的特性。</p>
<p><strong>stack和queue可以选择list或者deque作为底层结构，不可以选择map/set。</strong></p>
<p>stack可以选择vector作为底层结构，但是queue不可以，因为queue调用pop的时候需要调用vector的pop_front，但是vector没有这个函数。</p>
<h2 id="Assosiative-Containers"><a href="#Assosiative-Containers" class="headerlink" title="Assosiative Containers"></a>Assosiative Containers</h2><p><img src="https://i.imgur.com/yomZTeh.png" alt><br>关联式容器的底层实现是红黑树和hashtable。</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><img src="https://i.imgur.com/UvMF98x.png" alt></p>
<p>红黑树是平衡二叉搜索树中经常被使用的一种。平衡二叉搜索树的特征：排列规则有利于search和insert，并且保持适度平衡。</p>
<p>红黑树按照正常规则遍历(++)便能够获得排序状态。红黑树从最左边的结点开始遍历，遍历到最右边的结点。另外红黑树有个头结点，是个空结点，便于操作。</p>
<p>虽然红黑树提供iterator，但是我们不应该用iterator来改变元素的值，这样会破坏红黑树的结构。</p>
<p>红黑树有两种插入：insert_unique和insert_equal，前一种不允许key重复，后一种允许。</p>
<p><img src="https://i.imgur.com/BLlPEyg.png" alt></p>
<p>红黑树的模板参数包括五个：</p>
<ul>
<li>key 的类型</li>
<li>value (key+data)的类型</li>
<li>keyOfValue key应该如何得到</li>
<li>Compare 元素如何比大小</li>
<li>alloc</li>
</ul>
<p>参数：</p>
<ul>
<li>node_account, 结点数量,4</li>
<li>header，指向红黑树的结点,4</li>
<li>Compare，可能是仿函数，大小应该是0，创造出来的对象大小是1</li>
</ul>
<pre><code>rb_tree&lt;int,int,identity&lt;int&gt;,less&lt;int&gt;,alloc&gt; myTree;</code></pre><p>这是一个堆红黑树的使用。<br>其中identity是gnu C的一个仿函数，返回元素本身，less是标准库的一个比大小的函数。</p>
<pre><code>template &lt;class T&gt;
struct identity:public unary_function&lt;T,T&gt;
{
    const T&amp; operator()(const T&amp; x) const { return x; }
}
struct less:public binary_function&lt;T,T,bool&gt;
{
    bool operator()(const T&amp; x,const T&amp;y) const
    return { x&lt;y; }
}</code></pre><p><strong>问题：红黑树和AVT有什么区别？</strong></p>
<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>set/mulitset以红黑树为底层结构，key和value合二为一。</p>
<p>set调用insert_unique()，multiset调用insert_equal()。</p>
<p><img src="https://i.imgur.com/Jk6QPjd.png" alt></p>
<p>set的底层实现实际上就是一颗红黑树，看上图可以看到从set的声明到set的模板参数到树的参数的转换。</p>
<p>但是我们无法使用set/multiset的iterator改变元素值，这是怎么实现的呢？看源码，set中定义了一个iterator,是const_iterator类型，这就保证了不允许改元素的值。</p>
<p>查找速度非常快。</p>
<h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>和set不同的地方是，map把key和data包成一个包，keyOfValue是select1st。之前的set是把iterator变成const，这里是把key变成const。</p>
<pre><code>insert(pair&lt;long,string&gt;(i,buf));</code></pre><p>map在插入的时候可以使用<code>c[i]=string(buf)</code>，但是multimap不可以。<br>[]的作用是返回下标对应的元素值，如果不存在，则用默认值创建然后返回。源代码可以看对[]的重载，首先利用<code>lower bound</code>进行查找，如果有这个元素，就返回下标，否则就返回适合这个元素插入的位置，然后执行<code>insert()</code>函数。</p>
<h3 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h3><p>bucket_count()可能比元素多，因为有的篮子可能是空的。当元素&gt;=篮子数，篮子就会扩充，把元素重新打散。打散的方式就是把篮子*2附近的质数，所有的元素都要重新计算一遍。</p>
<p>hashtable的模板参数：</p>
<p><img src="https://i.imgur.com/QIsE17Z.png" alt></p>
<ul>
<li>hash 1</li>
<li>equals 1</li>
<li>get_key 1</li>
<li>bukets 12</li>
<li>num_elements 4</li>
</ul>
<p>hashtable的iterator必须能够从当前节点回到buckets，所以有一个指针ht指向hashtable本身。</p>
<p>hashtable的应用：</p>
<pre><code>hashtable&lt;const char*,
          const char*,
          hash&lt;const char*&gt;,
          identity&lt;const char*&gt;,
          eqstr,
          alloc&gt;
ht(50,hash&lt;const char*&gt;(),eqstr());
ht.insert_unique(&quot;kiwi&quot;);
ht.insert_unique(&quot;apple&quot;);

struct eqstr{bool operator()(const char*s1, s2)const
{ return strcmp(s1,s2)==0; }}</code></pre><p>为什么这里不用strcmp呢？因为strcmp返回值是-1,0,1，不是返回bool，所以必须加一层外套。</p>
<p>在gnuC中，有一个结构体struct hash{}; 还有hash<char>等等，这是一种泛化和特化。如果是数值，返回本身的值。如果是char<em>，利用__stl_hash_string(const char</em>s)这个函数将字符串映射成一个数值。这里是乘以5再加上下一个字符迭代。这里的hash函数可以定义实现。但是标准库没有提供hash<a href="std::string" target="_blank" rel="noopener">std::string</a>的函数。</char></p>
<p>决定每个元素落在哪个篮子里最终都是调用<code>bkt_num_key</code>这个函数，返回<code>hash(key)%n</code>，其中这里的hash不是上面的struct hash，而是hasher的hash。</p>
<p><strong>hasher这里的hash是做什么用的？</strong></p>
<h3 id="unordered-multiset-multimap"><a href="#unordered-multiset-multimap" class="headerlink" title="unordered multiset/multimap"></a>unordered multiset/multimap</h3><p>实际上unordered_(multi)list/set就是之前的hash_(multi)list/set，使用方法和slist一样，#include&lt;ext/slist&gt;。</p>
<h1 id="分配器-allocators"><a href="#分配器-allocators" class="headerlink" title="分配器 allocators"></a>分配器 allocators</h1><p>尽量使用容器而不要使用分配器，因为分配器不像malloc和free，它还内存的时候还要指定特定的字节。</p>
<h2 id="operator-new-和-malloc"><a href="#operator-new-和-malloc" class="headerlink" title="operator new() 和 malloc()"></a>operator new() 和 malloc()</h2><p>所有的获取空间追究到底层都是malloc()。<br>malloc会生成一个(五彩内存分配图)。</p>
<h2 id="VC6-的-allocator"><a href="#VC6-的-allocator" class="headerlink" title="VC6 的 allocator"></a>VC6 的 allocator</h2><p>allocator-&gt;operator new-&gt;malloc。<br>VC6的allocator只是以operator new 和operator delete 完成allocate()和deallocate()，没有任何特殊设计。</p>
<p>在delete的时候，需要指定要回收多少字节。</p>
<h2 id="BC5-的-allocator"><a href="#BC5-的-allocator" class="headerlink" title="BC5 的 allocator"></a>BC5 的 allocator</h2><p>BC5的allocator只是以operator new 和operator delete 完成allocate()和deallocate()，没有任何特殊设计。</p>
<p>比VC6贴心的是第二个参数VC6需要给一个指针，而BC5第二个参数给了默认值。</p>
<h2 id="GCC2-9-的-allocator"><a href="#GCC2-9-的-allocator" class="headerlink" title="GCC2.9 的 allocator"></a>GCC2.9 的 allocator</h2><p>GCC2.9的allocator只是以operator new 和operator delete 完成allocate()和deallocate()，没有任何特殊设计。</p>
<p>但是这个allocator并不是容器所使用的，源代码中使用的是alloc。</p>
<p>当分配的内存比较小的时候，用malloc比较浪费空间，因为它还需要申请空间记录其他信息，其中cookie记录的是这块空间的大小，用于指针回收的时候知道要回收多少。</p>
<p><img src="https://i.imgur.com/XC1Nq16.png" alt></p>
<p>alloc的结构如图，它一共分为16块，0号存储8个字节的，1号存储16个字节的，以此类推。当下面没有分配内存时才调用一次malloc。</p>
<p>具体需要看内存管理。</p>
<h2 id="G4-9-的-allocator"><a href="#G4-9-的-allocator" class="headerlink" title="G4.9 的 allocator"></a>G4.9 的 allocator</h2><p>G4.9 -&gt; std::allocator -&gt; new_allocator -&gt; allocate -&gt; operator new</p>
<p>在G4.9中没有用上面那个特殊设计的alloc，而是沿用了之前的分配器。但是alloc还在。</p>
<p>G4.9 有很多extension allcoators，其中__pool_alloc就是G2.9的alloc。</p>
<pre><code>vector&lt;string,__gnu_cxx::__pool_alloc&lt;string&gt;&gt; vec;</code></pre><p>真是源码面前无秘密啊。</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="traits的作用"><a href="#traits的作用" class="headerlink" title="traits的作用"></a>traits的作用</h2><p>traits能够萃取出一个类型的特征，有iterator traits, type traits, pointer traits等等。</p>
<h2 id="iterator需要遵循的原则（特性）"><a href="#iterator需要遵循的原则（特性）" class="headerlink" title="iterator需要遵循的原则（特性）"></a>iterator需要遵循的原则（特性）</h2><p>迭代器是算法和容器之间的桥梁。算法在对容器操作的时候需要知道容器的一些性质，比如rotate这个函数，调用了iterator_category()（判断这个容器是能++/–/+i），difference type()（两个iterator之间的距离用什么类型表现，比如unsigned integer范围2^32）, value type()（iterator本身指向的是什么数据类型）。</p>
<p>associated type:</p>
<ul>
<li>category</li>
<li>difference type</li>
<li>value type</li>
<li>reference type</li>
<li>pointer type</li>
</ul>
<p>当算法提问的时候，可以直接提问：<br><code>I::iterator_category</code></p>
<p>但是当iterator不是一个class的时候不可以这么调用，比如指针，是一个iterator（指针是退化的iterator，iterator是泛化的pointer），但是不是class，所以这时候需要用traits来萃取pointer的特征，来回答算法的提问。traits是一个中间层，他能够区分它所获得的iterator是class还是pointer。用偏特化可以实现。</p>
<p><img src="https://i.imgur.com/DpBxGBS.png" alt></p>
<p>当算法提问的时候，问iterator_traits。<br>如果I是class，那么进入1，如果是pointer to T就进入2，如果是pointer to const T，就进入3.</p>
<p>但是当I是pointer to const T的时候，value_type是T而不是const T。因为value_type的主要目的是声明变量，而一个无法被复制的变量没有用，所以iterator的value_type不应该加const。</p>
<h2 id="不同容器的迭代器类型"><a href="#不同容器的迭代器类型" class="headerlink" title="不同容器的迭代器类型"></a>不同容器的迭代器类型</h2><p>迭代器共有5中iterator category:</p>
<ul>
<li>input_iterator_tag</li>
<li>output_iterator_tag</li>
<li>forward_iterator_tag: public input_iterator_tag</li>
<li>bidirectional_iterator_tag: public forward_iterator_tag</li>
<li>random_access_iterator_tag: public bidirectional_iterator tag</li>
</ul>
<p>对于sequence containers来说：</p>
<p>array, vector, deque是random_access_iterator_tag</p>
<p>list是bidirectional_iterator_tag</p>
<p>forward_list是forward_iterator_tag</p>
<p>对于Associative containers：</p>
<p>(multi)set/map 是bidirectional_iterator</p>
<p>unordered_(multi)set/map 要看vector下面是用的单向链表还是双向链表来判断。</p>
<p>下面是用程序测试各种容器的iterator类型的代码：</p>
<p><img src="https://i.imgur.com/uIwhVDf.png" alt></p>
<p>另外还可以使用<code>cout&lt;&lt;&quot;typeid(itr).name()=&quot;&lt;&lt;typeid(itr).name()&lt;&lt;endl;</code>来打印出各种容器的iterator_category的typeid。打印出的typeid在前面输出的前后会加一些东西，这是由编译器的具体实现决定的。</p>
<p>调用函数<code>display_category</code>，利用traits::iterator_category来询问迭代器的类型。</p>
<p>为什么这个类型不用12345的数字来表示，而用一个结构体呢？<br>看上面的程序就可以知道，用结构体能写的更规范。另外一个原因是，参考算法那部分的distance例子，这里只设计了两个函数，分别针对random_access_iterator和input_iterator，当有比如forward_iterator的时候，由于它继承了input_iterator，所以它是一种input_iterator，所以会调用input_iterator对应的函数。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>STL中的算法是什么？</p>
<p>从语言层面上来讲，STL除了算法是function template之外，其他都是class template。<br><code>template&lt;typename Iterator&gt;
Algorithm(Iterator it1, Iterator it2,(typename Cmp)){...}</code></p>
<p>算法看不到容器，所以它需要的一切信息都必须从Iterator中获得，Iterator必须能够回答算法的所有提问，才能搭配算法的所有操作。</p>
<h2 id="迭代器对算法的影响"><a href="#迭代器对算法的影响" class="headerlink" title="迭代器对算法的影响"></a>迭代器对算法的影响</h2><p>算法的效率和迭代器的类型有很大的关系。</p>
<p>举个例子来说，加入有一个函数<code>distance()</code>用于计算两个迭代器之间的距离。由于random_access_iterator和其他iterator不一样，它只需要用两个指针相减就可以了，而其他迭代器需要遍历两个迭代器，并且用n来计数。注意这里调用的是<code>category()</code>临时对象。同时返回值是<code>difference_type</code>。对于100万条数据来说，这两种函数的效率可见一斑。</p>
<p><img src="https://i.imgur.com/Cw96Ahr.png" alt></p>
<p>同理advance函数也有相同的结构，这个函数的作用是向前进。假如是random_access，就直接+=n，如果是双向，判断n的正负，如果是单向，就<code>while (n--) ++i;</code>.</p>
<p>再举一个例子，copy这个函数。从下面可以看到这个函数对于不同情况的分类有多么精细。首先判断copy的对象是不是const char<em>/wchar_t，如果是的话，就调用<code>memmove()</code>，这个函数是底层的拷贝函数，速度非常快。如果不是的话，再判断是不是指针 const T</em>，如果是的话，判断有没有重要的拷贝复制，如果没有的话，调用 <code>memmove()</code>，如果有的话，调用<code>__copy_d()</code>，对于不是指针的iterator来说，判断是不是random、_access类型，是的话调用<code>__copy_d()</code>，不是的话以iterator是否相等来决定for-loop函数。这个函数和<code>__copy_d()</code>相比较慢。另外，判断拷贝复制是不是重要主要看这个类里面有没有指针，如果没有指针，那么拷贝赋值函数可以直接用底层函数赋值，如果有指针就需要调用拷贝复制了。<br>这一部分叫做<code>type_traits</code>。</p>
<p><img src="https://i.imgur.com/mlcMk9j.png" alt></p>
<p>但是算法源码中对iterator_category没有强制，而是“暗示”。比如</p>
<pre><code>template &lt;class RandomAccessIterator&gt;
inline void sort(...){...}</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag">#C++</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/30/C++学习笔记4/" rel="next" title="C++学习笔记4--C++11">
                <i class="fa fa-chevron-left"></i> C++学习笔记4--C++11
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/08/金融思维7/" rel="prev" title="金融思维7：资本资产定价 股票/公司估值">
                金融思维7：资本资产定价 股票/公司估值 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
            <div id="uyan_frame"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/img/3.jpg" alt="StoneHan">
          <p class="site-author-name" itemprop="name">StoneHan</p>
          <p class="site-description motion-element" itemprop="description">想把你写成一首歌，想养一只猫</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Stone-Han" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2133952903/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#STL六大部件"><span class="nav-number">1.</span> <span class="nav-text">STL六大部件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GP-vs-OOP"><span class="nav-number">2.</span> <span class="nav-text">GP vs. OOP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#容器"><span class="nav-number">3.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Sequence-Containers"><span class="nav-number">3.1.</span> <span class="nav-text">Sequence Containers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#array"><span class="nav-number">3.1.1.</span> <span class="nav-text">array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">3.1.2.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">3.1.3.</span> <span class="nav-text">list</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#list-的-iterator"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">list 的 iterator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G4-9"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">G4.9</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forward-list"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">forward list</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">3.1.4.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack-queue"><span class="nav-number">3.1.5.</span> <span class="nav-text">stack/queue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Assosiative-Containers"><span class="nav-number">3.2.</span> <span class="nav-text">Assosiative Containers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#红黑树"><span class="nav-number">3.2.1.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-multiset"><span class="nav-number">3.2.2.</span> <span class="nav-text">set/multiset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-multimap"><span class="nav-number">3.2.3.</span> <span class="nav-text">map/multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashtable"><span class="nav-number">3.2.4.</span> <span class="nav-text">hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unordered-multiset-multimap"><span class="nav-number">3.2.5.</span> <span class="nav-text">unordered multiset/multimap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分配器-allocators"><span class="nav-number">4.</span> <span class="nav-text">分配器 allocators</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#operator-new-和-malloc"><span class="nav-number">4.1.</span> <span class="nav-text">operator new() 和 malloc()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VC6-的-allocator"><span class="nav-number">4.2.</span> <span class="nav-text">VC6 的 allocator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BC5-的-allocator"><span class="nav-number">4.3.</span> <span class="nav-text">BC5 的 allocator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCC2-9-的-allocator"><span class="nav-number">4.4.</span> <span class="nav-text">GCC2.9 的 allocator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G4-9-的-allocator"><span class="nav-number">4.5.</span> <span class="nav-text">G4.9 的 allocator</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器"><span class="nav-number">5.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#traits的作用"><span class="nav-number">5.1.</span> <span class="nav-text">traits的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iterator需要遵循的原则（特性）"><span class="nav-number">5.2.</span> <span class="nav-text">iterator需要遵循的原则（特性）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不同容器的迭代器类型"><span class="nav-number">5.3.</span> <span class="nav-text">不同容器的迭代器类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法"><span class="nav-number">6.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器对算法的影响"><span class="nav-number">6.1.</span> <span class="nav-text">迭代器对算法的影响</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">StoneHan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  



 

    
      
    

   
        <!-- UY BEGIN -->
		<div id="uyan_frame"></div>
		<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2135402"></script>
		<!-- UY END -->
    
  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
